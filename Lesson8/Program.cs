//Метод удаляющий из двумерного массива строку и столбец на пересечении которого 
//находится наименьший элемент в массиве
/*
int[,] DelMinStrings(int[,] array)
{
    int minI = 0; //итый индекс минимального элемента в массиве
    int minJ = 0; //джытый индекс минимального элемента в массиве

    for (int i = 0; i < array.GetLength(0); i++)
    {
        for (int j = 1; j < array.GetLength(1); j++)
        {  
            //Если текущий элемент двумерного массива меньше заданного минимального
            //от текущий эле 
            if(array[i,j] < array[minI, minJ])
            {
                minI = i;
                minJ = j; 
            } 
        }
    }
    
    for (int j = 0; j < array.GetLength(0); j++)
    {
        array[minI,j] = 0;
    }

    for (int i = 0; i < array.GetLength(1); i++)
    {
        array[i,minJ] = 0;
    }

    return array;
}

//Генерируем двумерный массив целых чисел 
int[,] CreateRandom2dArray(int row, int column, int minValue, int maxValue)
{
    int[,] newArray = new int[row, column];

    for (int i = 0; i < newArray.GetLength(0); i++)
    {
        for (int j = 0; j < newArray.GetLength(1); j++)
        {
            newArray[i, j] = new Random().Next(minValue, maxValue+1);
        }
    }
    return newArray;
}


//Выводим двумерный массив на печать 
void Show2dArray(int[,] array)
{
    for (int i = 0; i < array.GetLength(0); i++)
    {
        for (int j = 0; j < array.GetLength(1); j++)
        {
            Console.Write(array[i,j] + " ");
        }
        Console.WriteLine();
    }
}
int row = 5;
int column = 5;
int minValue = 1;
int maxValue = 9; 

int[,] array = CreateRandom2dArray(row, column, minValue, maxValue);
Show2dArray(array);
Console.WriteLine();
Show2dArray(DelMinStrings(array));
*/



int[] arrayBySort = new int [] {10, 8, 10, 12, 3, 3, 11, 9, 8}; //массив из 5 элементов
        int index = 0; //индекс первого (нулевого) элемента массива
        int maxIndex = 0; //предпологаем что под индексом 0 лежит элемент массива который является максимальным числом
        int temp = 0; //временная переменнная которая будет служить для обмена значений между ячейками массива
        int size = arrayBySort.Length; //переменная для хранения размера массива
        //int count = 0; переменная которая будет хранить количество уже отсортированных чисел массива

        //И так запускаем наш алгоритм (цикл) сортировки массива
        //и на каждой итерации проверяем условие все ли цифры отсортированны (т.е. сравниваем количество уже отсортированных
        //чисел с размером всего массива

        for (int count = 0; count < size; count++){

            //проходим циклом по всему массиву и по порядку сравниваем числа между собой, т.о. что крайняя правая ячейка массива
            //будет сравниваться только при первой итерации цикла а при последующих проходах она будет смещаться в лево тем самым
            //отсекая все отсортированные уже числа (ячейки)
            while (index < (size-count)){

            /*если число в array[index] (первый т.е. нулевой элемент массива) > числа в ячейке массива под индексом maxIndex
            в которой предположительно должно находиться максимальное число
            то в переменную maxIndex записывается номер индекса ячейки в которой на самом деле хранится очередное максимальное число
            и индекс массива увеличивается на 1, т.е. таким образом мы переходим к сравнению следующего элемента массива
            если условиие array[index] > числа в ячейке массива под индексом maxIndex невыполняется то число записанное
            в maxIndex не изменяется но индекс все равно увеличивается на 1, и мы переходим к сравнению следующего элемента массива*/

                if (arrayBySort[index] > arrayBySort[maxIndex]) maxIndex = index;
                index = index + 1;
            }

            Console.WriteLine("max = " + arrayBySort[maxIndex]);

            //после того как мы определили максимальное значение в массиве его теперь необходимо поместить в последнюю
            //ячейку массива но таким образом чтобы значение в ней не затерлость безвозвратно.
            //для этого будем использовать временную переменную temp

            temp = arrayBySort[size - 1 - count]; //для начала сохраним в temp значение из последней ячейки массива
            arrayBySort[size - 1 - count] = arrayBySort[maxIndex]; //теперь запишем в последнюю ячейку наше максимальное значение из массива
            //а в ячейку с максимальным значением запишем число которое мы ранее сохранили в переменную temp из последней ячейки массива
            arrayBySort[maxIndex] = temp;

            //после первой сортировки мы снова должны обнулить переменные index и maxIndex, чтобы снова начать сортировку с нулевого элемента
            index = 0;
            maxIndex = 0;

            //увелисиваем значение count на 1. Отсекая таким образом крайние правые отсортированные ячейки массива.
            
        }